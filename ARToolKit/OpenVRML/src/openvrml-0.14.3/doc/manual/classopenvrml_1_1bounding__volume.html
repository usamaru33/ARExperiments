<!doctype html public "-//W3C//DTD HTML 4.01 Transitional//EN"
               "http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>
<title>openvrml::bounding_volume class Reference</title>
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<link rel="icon" href="../vrml-16">
<link rel="start" href="http://openvrml.org/index" title="OpenVRML Home">
<link rel="prev" href="http://openvrml.org/discussion" title="Discussion">
<link rel="contents" href="index" title="Documentation Main Page">
<link rel="index" href="functions" title="OpenVRML Compound Members">
<link rel="appendix" href="conformance" title="Conformance Test Results">
<style type="text/css">
@import url("doxygen.css");
@import url("http://openvrml.org/openvrml.css");

.body td {
  background-color: transparent;
}

div.qindex {
  background-color: transparent;
  border: none;
}
a.qindex {
  text-decoration: inherit;
  color: inherit
}
a.qindex:visited {
  text-decoration: inherit;
  font-weight: inherit;
  color: inherit
}
a.qindex:hover {
  text-decoration: inherit;
  background-color: transparent;
}
a.qindexHL {
  text-decoration: inherit;
  font-weight: inherit;
  background-color: transparent;
  color: inherit;
}
a.qindexHL:hover {
  text-decoration: inherit;
  background-color: transparent;
  color: inherit;
}
a.qindexHL:visited {
  text-decoration: inherit;
  background-color: transparent;
  color: inherit;
}
a.el {
  text-decoration: inherit;
  font-weight: inherit
}
a.elRef {
  font-weight: inherit
}
a.code {
  text-decoration: inherit;
  font-weight: inherit;
  color: inherit;
}
a.codeRef {
  font-weight: normal;
  color: inherit;
}
a:hover {
  text-decoration: inherit;
  background-color: inherit;
}

h1 {
  line-height: 1.2em;
}

div.qindex {
  font-size: smaller;
}

div.qindex .qindex:link, div.qindex .qindex:visited {
  font-weight: inherit;
}

div.qindex .qindexHL:link, div.qindex .qindexHL:visited {
  font-weight: bold;
}

td.memItemLeft, td.memItemRight, .mdRow td {
  font-family: "Bitstream Vera Sans Mono",
               "LucidaTypewriter",
               "Lucida Console",
               monospace;
}

td.memItemLeft, td.memItemRight, td.mdescLeft, td.mdescRight {
  background-color: rgb(95%, 95%, 95%);
}

.mdRow {
  background-color: rgb(95%, 95%, 95%);
}

.mdTable {
  background-color: rgb(95%, 95%, 95%);
}

.mdRow td {
  background-color: rgb(95%, 95%, 95%);
}

.mdRow td code {
  font-family: sans-serif;
  font-style: italic;
}
</style>
</head>
<body>
<table class="sitenav">
  <tr>
    <th><a href="http://openvrml.org/index" title="Home">Home</a></th>
    <th><a href="http://openvrml.org/download" title="Download">Download</a></th>
    <th><a href="http://openvrml.org/screenshots/index" title="Screen shots">Screen shots</a></th>
    <th><a href="http://openvrml.org/discussion" title="Mailing lists and IRC">Discussion</a></th>
    <th>Documentation</th>
  </tr>
</table>
<div class="body">
<!-- Generated by Doxygen 1.3.4-20031112 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>openvrml::bounding_volume Class Reference</h1>A bounding volume.  
<a href="#_details">More...</a>
<p>
Inheritance diagram for openvrml::bounding_volume:<p><center><img src="classopenvrml_1_1bounding__volume__inherit__graph.png" border="0" usemap="#openvrml_1_1bounding__volume__inherit__map" alt="Inheritance graph"></center>
<map name="openvrml_1_1bounding__volume__inherit__map">
<area href="classopenvrml_1_1axis__aligned__bounding__box.html" shape="rect" coords="7,87,244,105" alt="">
<area href="classopenvrml_1_1bounding__sphere.html" shape="rect" coords="268,87,444,105" alt="">
</map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center><a href="classopenvrml_1_1bounding__volume-members.html">List of all members.</a><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>enum &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classopenvrml_1_1bounding__volume.html#w3">intersection</a> { <br>
&nbsp;&nbsp;<a class="el" href="classopenvrml_1_1bounding__volume.html#w3w0">inside</a> =  1, 
<br>
&nbsp;&nbsp;<a class="el" href="classopenvrml_1_1bounding__volume.html#w3w1">outside</a> =  -1, 
<br>
&nbsp;&nbsp;<a class="el" href="classopenvrml_1_1bounding__volume.html#w3w2">partial</a> =  0
<br>
 }</td></tr>

<tr><td colspan=2><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="a0" doxytag="openvrml::bounding_volume::~bounding_volume" ></a>
virtual&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classopenvrml_1_1bounding__volume.html#a0">~bounding_volume</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classopenvrml_1_1bounding__volume.html#a1">maximize</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Maximize the bounding volume.  <a href="#a1"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>virtual bool&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classopenvrml_1_1bounding__volume.html#a2">maximized</a> () const=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Indicates whether the bounding volume is maximized.  <a href="#a2"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>virtual <a class="el" href="classopenvrml_1_1bounding__volume.html#w3">intersection</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classopenvrml_1_1bounding__volume.html#a3">intersect_frustum</a> (const <a class="el" href="classopenvrml_1_1frustum.html">openvrml::frustum</a> &amp;<a class="el" href="classopenvrml_1_1frustum.html">frustum</a>) const=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Intersect this bvolume with a frustum.  <a href="#a3"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classopenvrml_1_1bounding__volume.html#a4">extend</a> (const <a class="el" href="classopenvrml_1_1bounding__volume.html">bounding_volume</a> &amp;bv)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extend the <a class="el" href="classopenvrml_1_1bounding__volume.html">bounding_volume</a> to enclose <code>bv</code>.  <a href="#a4"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classopenvrml_1_1bounding__volume.html#a5">extend</a> (const <a class="el" href="classopenvrml_1_1vec3f.html">vec3f</a> &amp;p)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extend the bounding volume to enclose <code>p</code>.  <a href="#a5"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classopenvrml_1_1bounding__volume.html#a6">extend</a> (const <a class="el" href="classopenvrml_1_1axis__aligned__bounding__box.html">axis_aligned_bounding_box</a> &amp;bbox)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extend the bounding volume to enclose <code>bbox</code>.  <a href="#a6"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classopenvrml_1_1bounding__volume.html#a7">extend</a> (const <a class="el" href="classopenvrml_1_1bounding__sphere.html">bounding_sphere</a> &amp;bs)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extend this bvolume to enclose the given sphere.  <a href="#a7"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classopenvrml_1_1bounding__volume.html#a8">enclose</a> (const std::vector&lt; <a class="el" href="classopenvrml_1_1vec3f.html">vec3f</a> &gt; &amp;points)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enclose the given set of points.  <a href="#a8"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classopenvrml_1_1bounding__volume.html#a9">ortho_transform</a> (const <a class="el" href="classopenvrml_1_1mat4f.html">mat4f</a> &amp;M)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transform this bounding volume using an orthogonal transfom.  <a href="#a9"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>virtual void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classopenvrml_1_1bounding__volume.html#a10">transform</a> (const <a class="el" href="classopenvrml_1_1mat4f.html">mat4f</a> &amp;M)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transform this bounding volume using an affine transfom.  <a href="#a10"></a><br><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
A bounding volume. 
<p>
All the geometry in a scene maintains a bounding volume to help speed up rendering and picking. Although currently we're just using spheres, the plan is to eventually use tighter bounds like axis aligned boxes around nodes that are expected to be static. That probably means boxes for geometry and spheres for grouping nodes.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classopenvrml_1_1node.html#a67">node::render</a> <p>
<a class="el" href="classopenvrml_1_1bounding__sphere.html">bounding_sphere</a> <p>
<a class="el" href="classopenvrml_1_1axis__aligned__bounding__box.html">axis_aligned_bounding_box</a> </dd></dl>

<p>
<hr><h2>Member Enumeration Documentation</h2>
<a class="anchor" name="w3" doxytag="openvrml::bounding_volume::intersection" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> enum <a class="el" href="classopenvrml_1_1bounding__volume.html#w3">openvrml::bounding_volume::intersection</a>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b>Enumeration values: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="anchor" name="w3w0" doxytag="inside" ></a>inside</em>&nbsp;</td><td>
Results of an intersection; indicates that the tested volume is entirely inside the target volume. </td></tr>
<tr><td valign=top><em><a class="anchor" name="w3w1" doxytag="outside" ></a>outside</em>&nbsp;</td><td>
Results of an intersection; indicates that the tested volume is entirely outside the target volume. </td></tr>
<tr><td valign=top><em><a class="anchor" name="w3w2" doxytag="partial" ></a>partial</em>&nbsp;</td><td>
Results of an intersection; indicates that the tested volume intersects with the target volume. </td></tr>
</table>
</dl>
    </td>
  </tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="a8" doxytag="openvrml::bounding_volume::enclose" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void openvrml::bounding_volume::enclose </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const std::vector&lt; <a class="el" href="classopenvrml_1_1vec3f.html">vec3f</a> &gt; &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>points</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Enclose the given set of points. 
<p>
This resets the volume from any previous values.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>points</em>&nbsp;</td><td>points. </td></tr>
  </table>
</dl>

<p>
Implemented in <a class="el" href="classopenvrml_1_1bounding__sphere.html#a7">openvrml::bounding_sphere</a>, and <a class="el" href="classopenvrml_1_1axis__aligned__bounding__box.html#a6">openvrml::axis_aligned_bounding_box</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a7" doxytag="openvrml::bounding_volume::extend" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void openvrml::bounding_volume::extend </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classopenvrml_1_1bounding__sphere.html">bounding_sphere</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>b</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Extend this bvolume to enclose the given sphere. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>b</em>&nbsp;</td><td>a bounding sphere </td></tr>
  </table>
</dl>

<p>
Implemented in <a class="el" href="classopenvrml_1_1bounding__sphere.html#a6">openvrml::bounding_sphere</a>, and <a class="el" href="classopenvrml_1_1axis__aligned__bounding__box.html#a5">openvrml::axis_aligned_bounding_box</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a6" doxytag="openvrml::bounding_volume::extend" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void openvrml::bounding_volume::extend </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classopenvrml_1_1axis__aligned__bounding__box.html">axis_aligned_bounding_box</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>bbox</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Extend the bounding volume to enclose <code>bbox</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>bbox</em>&nbsp;</td><td>an axis-aligned bounding box. </td></tr>
  </table>
</dl>

<p>
Implemented in <a class="el" href="classopenvrml_1_1bounding__sphere.html#a5">openvrml::bounding_sphere</a>, and <a class="el" href="classopenvrml_1_1axis__aligned__bounding__box.html#a4">openvrml::axis_aligned_bounding_box</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a5" doxytag="openvrml::bounding_volume::extend" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void openvrml::bounding_volume::extend </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classopenvrml_1_1vec3f.html">vec3f</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>p</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Extend the bounding volume to enclose <code>p</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>p</em>&nbsp;</td><td>a point </td></tr>
  </table>
</dl>

<p>
Implemented in <a class="el" href="classopenvrml_1_1bounding__sphere.html#a4">openvrml::bounding_sphere</a>, and <a class="el" href="classopenvrml_1_1axis__aligned__bounding__box.html#a3">openvrml::axis_aligned_bounding_box</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a4" doxytag="openvrml::bounding_volume::extend" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void openvrml::bounding_volume::extend </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classopenvrml_1_1bounding__volume.html">bounding_volume</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>bv</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Extend the <a class="el" href="classopenvrml_1_1bounding__volume.html">bounding_volume</a> to enclose <code>bv</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>bv</em>&nbsp;</td><td>a bounding volume. </td></tr>
  </table>
</dl>

<p>
Implemented in <a class="el" href="classopenvrml_1_1bounding__sphere.html#a3">openvrml::bounding_sphere</a>, and <a class="el" href="classopenvrml_1_1axis__aligned__bounding__box.html#a2">openvrml::axis_aligned_bounding_box</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a3" doxytag="openvrml::bounding_volume::intersect_frustum" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classopenvrml_1_1bounding__volume.html#w3">bounding_volume::intersection</a> openvrml::bounding_volume::intersect_frustum </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classopenvrml_1_1frustum.html">openvrml::frustum</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>frustum</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Intersect this bvolume with a frustum. 
<p>
The test assumes that the frustum is in the canonical looking-down-negative-z orientation, so the bounding volume is going to have to be transformed into the frustum's space. (Alternatives include transforming the frustum into the bvolume's space, or transforming both of them into the projection space. Lots of tradeoffs involved, but transforming the bvolume is probably the simplest approach overall.)<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>frustum</em>&nbsp;</td><td>the frustum.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>inside, outside, or partial.</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classopenvrml_1_1bounding__volume.html#a10">bounding_volume::transform</a> <p>
<a class="el" href="classopenvrml_1_1bounding__volume.html#a9">bounding_volume::ortho_transform</a> </dd></dl>

<p>
Implemented in <a class="el" href="classopenvrml_1_1bounding__sphere.html#a2">openvrml::bounding_sphere</a>, and <a class="el" href="classopenvrml_1_1axis__aligned__bounding__box.html#a1">openvrml::axis_aligned_bounding_box</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a1" doxytag="openvrml::bounding_volume::maximize" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void openvrml::bounding_volume::maximize </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Maximize the bounding volume. 
<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classopenvrml_1_1bounding__volume.html#a2">maximized</a> </dd></dl>

<p>
Implemented in <a class="el" href="classopenvrml_1_1bounding__sphere.html#a8">openvrml::bounding_sphere</a>, and <a class="el" href="classopenvrml_1_1axis__aligned__bounding__box.html#a7">openvrml::axis_aligned_bounding_box</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a2" doxytag="openvrml::bounding_volume::maximized" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> bool openvrml::bounding_volume::maximized </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Indicates whether the bounding volume is maximized. 
<p>
The convention is that nodes that should be rendered unconditionally set a maximum bounding volume, ensuring that the branch they are on does not get pruned during culling. Stuff like the picking code needs a way to differentiate this from just a really big bounding volume, or an unset bounding volume.<p>
<dl compact><dt><b>Returns:</b></dt><dd><code>true</code> if the bounding voume is maximized; <code>false</code> otherwise.</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classopenvrml_1_1bounding__volume.html#a1">maximize</a> </dd></dl>

<p>
Implemented in <a class="el" href="classopenvrml_1_1bounding__sphere.html#a9">openvrml::bounding_sphere</a>, and <a class="el" href="classopenvrml_1_1axis__aligned__bounding__box.html#a8">openvrml::axis_aligned_bounding_box</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a9" doxytag="openvrml::bounding_volume::ortho_transform" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void openvrml::bounding_volume::ortho_transform </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classopenvrml_1_1mat4f.html">mat4f</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>M</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Transform this bounding volume using an orthogonal transfom. 
<p>
Orthogonal transformations preserve angles. They include translation, rotation, and uniform scaling. It turns out to be so easy to transform bounding spheres by orthogonal transformations that it's worth special casing. The caller is responsible for assuring that the transformation is in fact orthogonal, otherwise the results are undefined. If in doubt, call transform instead and take the speed hit.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>M</em>&nbsp;</td><td>orthonormal transformation matrix in <a class="el" href="classopenvrml_1_1mat4f.html">mat4f</a> format</td></tr>
  </table>
</dl>
<dl compact><dt><b>See also:</b></dt><dd>MathUtils </dd></dl>

<p>
Implemented in <a class="el" href="classopenvrml_1_1bounding__sphere.html#a10">openvrml::bounding_sphere</a>, and <a class="el" href="classopenvrml_1_1axis__aligned__bounding__box.html#a9">openvrml::axis_aligned_bounding_box</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a10" doxytag="openvrml::bounding_volume::transform" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void openvrml::bounding_volume::transform </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classopenvrml_1_1mat4f.html">mat4f</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>M</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Transform this bounding volume using an affine transfom. 
<p>
Affine transformations can include nonuniform scaling. It is much messier to deal with them, but VRML allows nonuniform scaling, so we have to handle it. Note that since all orthogonal transforms are affine, it's safe to always call this routine instead of <code>ortho_transform</code>, but it's likely to be slower. The results are undefined if this routine is called with a non-affine argument. Note that VRML Transform nodes only allow affine transformations, so unless you're doing something tricky this routine should always be safe.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>M</em>&nbsp;</td><td>affine transformation matrix. </td></tr>
  </table>
</dl>

<p>
Implemented in <a class="el" href="classopenvrml_1_1bounding__sphere.html#a11">openvrml::bounding_sphere</a>, and <a class="el" href="classopenvrml_1_1axis__aligned__bounding__box.html#a10">openvrml::axis_aligned_bounding_box</a>.    </td>
  </tr>
</table>
</div>
<address class="footer"><a href="http://sourceforge.net"><img src="http://sourceforge.net/sflogo.php?group_id=7151&amp;type=3" width="125" height="37" border="0" alt="SourceForge.net Logo" align="right"></a><a href="http://sourceforge.net/tracker/?func=add&amp;group_id=7151&amp;atid=107151">Report error</a><br>Generated Sun Nov 16 20:22:39 2003 by Doxygen 1.3.4-20031112</address>
</body>
</html>
